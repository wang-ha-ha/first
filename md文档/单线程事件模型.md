##### 控制逻辑部分

* 事件队列：参数、外设的操作不能直接控制，通过事件队列，发送到处理线程，在处理线程同一管理
* 事件处理结果队列：事件处理完成后，将事件处理结果放入该队列
* 事件处理线程：从事件队列里面获取事件，执行对应的操作，将操作结果放入事件处理结果队列



##### 需要的事件类型

1. 电机
   * 控制电机打开和关闭

2. 称重小板hx711数据采集
   * 现在hx711是连续读12次，去掉最大最小，取平均值

3. 蜂鸣器

   * 控制蜂鸣器的打开和关闭

   * 蜂鸣器控制现在使用了一个定时器，用于实现长短鸣

4. Flash参数存储

   * Flash参数的读取只会在上电初始化的时候读取到内存

   * 每次参数修改都会去存储

##### 事件启动的消息来源

1. 上位机
   * 打杯制作命令（打开电机）
   * 配置参数命令（写参数）
   * 读取参数（如果修改Flash存储框架，每次读取也需要去操作Flash）

2. PWM脉冲回调函数
   * 达到打杯量脉冲时要停止电机

3. USB接口
   * U盘升级完成，会动作蜂鸣器



##### 事件处理过程

1. 注册事件，分配事件类型 event_handle ，注册事件处理的回调函，存放在事件表
   * 注册事件时，可以分成几类事件去注册，比如I/O控制的事件注册，参数存储的事件类型等等
2. 发送事件，就直接使用 event_handle，如果事件回调函数需要参数，还需传入参数
3. 删除事件，在事件表中，删除 event_handle  
4. 阻塞等待事件队列，在事件表中查找对应的事件处理回调函数
5. 处理完成后，如果需要返回结果，就将结果放在事件结果队列的



##### 事件消息队列数据结构

```c
struct _event_t
{
    unsigned int event_handle;
    unsigned int event_type;  //出现一些故障时，不让某些类型事件进行处理
    unsigned int (*callback)(void *);
    struct _event_t *next;
}

struct _event_table_t //可以做成hash表
{
    unsigned int len;
    struct _event_t *head;
}

struct _msg_event_queque_t
{
  	unsigned int        event_handle;//事件的句柄
    unsigned int            event_id;//事件ID，用来识别事件处理结果
    void                       *argv;	  
    struct _msg_event_queque_t *next;
};
```





------

###### PS

* 就是以前直接操作一些外设，比如打开一个I/O口，直接调用函数就调用打开了，然后打开I/O口在很多地方都会被调用。现在这个修改的意思，就是打开I/O口不是直接打开，而是发送一个打开I/O的消息，让消息处理线程去处理。这样就方便同一管理。

* ==》结果队列里面的执行结果可能是乱序的（因为有任务耗时，执行时间长，而某些任务直接先完成了。）

  ​    	为什么会出现这种结果？事件处理线程都是单线程阻塞的，只有处理完一件事情之后，在去接收消息队列的消息，继续进行处理，

  ​		额外开定时器，在定时器回调处理函数里面去回消息，这样才可能导致执行结果是乱序的

* 还是比较混乱

* 执行有时序的任务，在等待时间的时候，现在都用的阻塞的方式；如果使用单线程执行会拖延所有任务，我们可以把阻塞的时间去开一个定时器，时间到了之后从定时器里面去发送任务。



------

##### 单线程的好处

- 不用上下切换线程造成损耗，不用添加各种互斥锁、信号量等
- 



------

##### 单线程与多线程的对比

> 我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。
>
> **经营方式一**
> 客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题
>
> - 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
> - 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
> - 快递员之间的协调很花时间
>
> 综合上述缺点，小曲痛定思痛，提出了下面的经营方式
>
> **经营方式二**
> 小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按**送达地点**标注好，然后**依次**放在一个地方。最后，那个快递员**依次**的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。
>
> **对比**
> 上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:
>
> - 每个快递员------------------>每个线程
> - 每个快递-------------------->每个socket(I/O流)
> - 快递的送达地点-------------->socket的不同状态
> - 客户送快递请求-------------->来自客户端的请求
> - 小曲的经营方式-------------->服务端运行的代码
> - 一辆车---------------------->CPU的核数
>
> 于是我们有如下结论
> 1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。
> 2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。